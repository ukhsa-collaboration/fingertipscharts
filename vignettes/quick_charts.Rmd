---
title: "Producing charts from Fingertips"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Creating the charts available on Fingertips}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

This vignette demonstrates how to create some of the charts available in this package. All of the names of the functions match the name for the chart on Fingertips.

### A note on ordering within the charts

The charts produced, generally, order the data alphabetically. In the [static map](#static) section and the [compare areas](#compareareas), there are worked examples of reordering the factor levels so they are presented in the required order in the legends.

## Libraries

```{r libraries, message=FALSE}
library(fingertipsR)
library(fingertipscharts)
library(dplyr)
library(tidyr)
library(broom)
library(geojsonio)
library(leaflet)
```

## Overview {#overview}

This function plots the **Overview** view (also known as the Tartan Rug). First, let's get some data:

```{r overview data, message=FALSE}
region <- "North East region"
top_names <- c("England", region)
dfdom <- fingertips_data(DomainID = 8000037) %>%
        group_by(IndicatorID) %>%
        filter(TimeperiodSortable == max(TimeperiodSortable) &
                       Sex == "Persons" &
                       (AreaName %in% top_names |
                                ParentName == region)) %>%
        ungroup() %>%
        mutate(Value = round(Value, 1))
```

This is how the `overview()` function works:

```{r overview, out.width='100%', fig.width=12, fig.height=6, fig.align='center'}
p <- overview(data = dfdom, 
              area = AreaName, 
              indicator = IndicatorName, 
              value = Value,
              fill = ComparedtoEnglandvalueorpercentiles,
              timeperiod = Timeperiod,
              top_areas = top_names, wrap_length = 40,
              value_label_size = 0.7)
p
```

## Compare indicators

Here is a function that helps produce a scatter plot as displayed on Fingertips. First the data needs to be changed to the correct format. The two variables that will be plotted need to be in separate fields. The `spread()` function from the `tidyr` package demonstrates how to do this below:

```{r compare indicators data}
df <- fingertips_data(c(90362, 90366)) %>%
        group_by(IndicatorID) %>%
        filter(TimeperiodSortable == max(TimeperiodSortable) &
                       Sex == "Male") %>%
        ungroup() %>%
        select(IndicatorID, AreaName, Value) %>%
        mutate(IndicatorID = paste0("x", IndicatorID)) %>%
        spread(IndicatorID, Value)
```

This is how the `compare_indicators()` function works:

```{r compare indicators, out.width='80%', fig.width=9, fig.height=5, fig.align='center',warning=FALSE}
p <- compare_indicators(data = df,
                        x = x90362,
                        y = x90366,
                        xlab = "Healthy life expectancy at birth",
                        ylab = "Life expectancy at birth",
                        highlight = c("England", "Dorset"),
                        area = AreaName,
                        add_R2 = TRUE)
p
```

## Maps

Here the package provides both interactive and static maps. 

The shape files need to be sources from the ONS Geography Portal. To do this, click on the API button [here](http://geoportal.statistics.gov.uk/datasets/counties-and-unitary-authorities-december-2016-ultra-generalised-clipped-boundaries-in-england-and-wales), using Counties and Unitary Authorities as an example, and then use the GeoJSON address as the string input to the `ons_api` parameter.

```{r map get data}
df <- fingertips_data(90366) %>%
        filter(Sex == "Male" &
                       AreaType == "County & UA" &
                       TimeperiodSortable == max(TimeperiodSortable))

ons_api <- "https://opendata.arcgis.com/datasets/687f346f5023410ba86615655ff33ca9_4.geojson"

```


### Static {#static}

**Note,** before plotting the chart, the levels of the field that is determining the fill of the polygons need to be reordered, as if they aren't, they will be ordered alphabetically in the legend:

```{r static reorder}
ordered_levels <- c("Better",
                    "Same", 
                    "Worse",
                    "Not compared")
df <- df %>%
        mutate(ComparedtoEnglandvalueorpercentiles = 
                       factor(ComparedtoEnglandvalueorpercentiles,
                              levels = ordered_levels))
```

The default map type is static:

```{r map static, out.width='80%', fig.width=8, fig.height=8, fig.align='center', warning=FALSE}
p <- fingertipscharts::map(data = df,
                    ons_api = ons_api,
                    area_code = AreaCode,
                    fill = ComparedtoEnglandvalueorpercentiles,
                    title = "Life expectancy at birth",
                    subtitle = "Males in Upper Tier Local Authorities England",
                    copyright_size = 3)
p
```

### Interactive

It is also possible to have interactive maps. Note, for this to work the value parameter must be included and subtitle doesn't work.

```{r map interactive, out.width='80%', fig.width=8, fig.height=8, fig.align='center', warning=FALSE}
p <- map(df,
         ons_api = ons_api,
         area_code = AreaCode,
         fill = ComparedtoEnglandvalueorpercentiles,
         type = "interactive",
         value = Value,
         name_for_label = AreaName,
         title = "Life expectancy at birth<br>Males within UTLAs in England")
p
```

## Trends

This function allows users to plot the trends graph. First, the data for life expectancy at birth for males is extracted:

```{r trends get data}
df <- fingertips_data(90366) %>%
        filter(Sex == "Male")
```

Here is an example of how to use the `trends()` function:

```{r trends, out.width='70%', fig.width=9, fig.height=5, fig.align='center'}
p <- trends(df,
            timeperiod = Timeperiod,
            value = Value,
            area = AreaName,
            comparator = "England",
            area_name = "Cambridgeshire",
            fill = ComparedtoEnglandvalueorpercentiles,
            lowerci = LowerCI95.0limit,
            upperci = UpperCI95.0limit,
            title = "Life expectancy at birth",
            subtitle = "Cambridgeshire compared to England",
            xlab = "Year",
            ylab = "Age (years)")
p
```

## Compare areas {#compareareas}

This code gets the latest year of data for IndicatorID 90316 filtered for local authorities whose parent is South East region and also the areas England and South East region:

```{r get fingertips data}
region <- "South East region"
top_names <- c("England", region)
df <- fingertips_data(90316) %>%
        group_by(IndicatorID) %>%
        filter(is.na(CategoryType) &
                       TimeperiodSortable == max(TimeperiodSortable) &
                       (AreaName %in% top_names |
                                ParentName == region)) %>%
        ungroup()
```

**Note,** before plotting the chart, the levels of the field that is determining the fill of the polygons need to be reordered, as if they aren't, they will be ordered alphabetically in the legend:

```{r compare areas reorder}
ordered_levels <- c("Better",
                    "Same", 
                    "Worse",
                    "Not compared")
df <- df %>%
        mutate(ComparedtoEnglandvalueorpercentiles = 
                       factor(ComparedtoEnglandvalueorpercentiles,
                              levels = ordered_levels)) %>%
        filter(Sex == "Persons")
```

The `compare_areas` function makes plotting the compare areas chart straight forward. 

```{r compare areas, out.width='80%', fig.width=9, fig.height=6, fig.align='center'}
p <- compare_areas(df, AreaName, Value,
                      fill = ComparedtoEnglandvalueorpercentiles,
                      lowerci = LowerCI95.0limit,
                      upperci = UpperCI95.0limit,
                      order = "desc",
                      top_areas = top_names,
                      title = unique(df$IndicatorName))
p
```

## Area profiles

The area profiles image is created using the `area_profiles()` function. This section shows how to produce a spine chart with the same data as in used in the [Overview](#overview) section, but the argument `rank = TRUE` needs to be included as this returns a polarity field, which is needed for the spine chart:

```{r area profiles data, cache=TRUE}
dfspine<- fingertips_data(DomainID = 1938132762,
                          rank = TRUE) %>%
        filter(((IndicatorID == 41001 &
                         Timeperiod == "2014 - 16" &
                         Sex == "Persons") |
                        (IndicatorID == 91393 &
                                 Timeperiod == "2011 - 15" &
                                 Sex == "Female") |
                        (IndicatorID == 92607 &
                                 Timeperiod == "2016" &
                                 Sex == "Not applicable")))
```


```{r area profiles, warning=FALSE, out.width='100%', fig.width=10, fig.height=4.5}
p <- area_profiles(dfspine,
                   value = Value,
                   count = Count,
                   area_code = AreaCode,
                   local_area_code = "E06000020",
                   indicator = IndicatorName,
                   timeperiod = Timeperiod,
                   polarity = Polarity,
                   significance = ComparedtoEnglandvalueorpercentiles,
                   area_type = AreaType,
                   cols = "fingertips",
                   median_line_area_code = "E92000001",
                   comparator_area_code = "E12000005",
                   datatable = TRUE,
                   relative_domain_text_size = 0.75,
                   relative_text_size = 1.2,
                   bar_width = 0.68,
                   indicator_label_nudgex = -0.5)
p
```

## Population

This function provides the ability to draw the traditional population pyramid. First, the population data is extracted using `fingertipsR` package. Also, note that the ordering of the age bands are defined prior to the data being provided to the `population()` function:

```{r population data}
agelevels <- c("0-4", "5-9","10-14","15-19",
               "20-24","25-29","30-34",
               "35-39","40-44","45-49",
               "50-54","55-59","60-64",
               "65-69","70-74","75-79",
               "80-84","85-89","90+")
pops <- fingertips_data(92708) %>%
        filter(TimeperiodSortable == max(TimeperiodSortable) &
                       Sex %in% c("Male", "Female") &
                       Age != "All ages") %>%
        mutate(Age = gsub(" yrs","", Age),
               Age = factor(Age,
                            levels = agelevels)) %>%
        droplevels()
```

This is how the function works:

```{r population, out.width='70%', fig.width=8, fig.height=7, fig.align='center'}
p <- population(pops,
                value = Value,
                sex = Sex,
                age = Age,
                area = AreaName,
                area_name = "Nottingham",
                comparator_1 = "England",
                comparator_2 = "East Midlands region",
                title = "Age Profile",
                subtitle = paste(unique(pops$IndicatorName),
                                 unique(pops$Timeperiod)),
                xlab = "% of total population")
p
```

## Box plots

Box plots can be found on some profiles. First the data is extracted using the `fingertipsR` package:

```{r boxplots data}
df <- fingertips_data(90366) %>%
        filter(Sex == "Male" &
                       AreaType == "County & UA")
```

This is how the function works. Note, the levels of the factor for the `timeperiod` parameter may need to be reordered, as this determines the order along the x-axis:

```{r boxplots, out.width='80%', fig.width=10, fig.height=7, fig.align='center'}
p <- box_plots(df,
               timeperiod = Timeperiod,
               value = Value,
               title = "Life expectancy at birth",
               subtitle = "Males in Upper Tier Local Authorities within England",
               ylab = "Age (years)")
p
```
